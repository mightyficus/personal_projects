import json
from strenum import StrEnum
import requests_oauthlib
import requests

# Dexcom Authentication

class URL(StrEnum):
    LOGIN =         "https://sandbox-api.dexcom.com/v2/oauth2/login"
    TOKEN =         "https://sandbox-api.dexcom.com/v2/oauth2/token"
    CALIBRATION =   "https://sandbox-api.dexcom.com/v2/users/self/calibration"
    DATA_RANGE =    "https://sandbox-api.dexcom.com/v2/users/self/dataRange"
    DEVICE =        "https://sandbox-api.dexcom.com/v2/users/self/devices"
    EGVS =          "https://sandbox-api.dexcom.com/v2/users/self/egvs"
    EVENTS =        "https://sandbox-api.dexcom.com/v2/users/self/events"


# This can be run at any time to refresh the access token
def access_token(payload):
    # Immediately check if access token can be obtained using a refresh code
    # set up a payload for refreshing the access token
    temp_payload = {
        "client_id":        payload["client_id"],
        "client_secret":    payload["client_secret"],
        "refresh_token":    payload["refresh_token"],
        "grant_type":       "refresh_token"
    }

    # This response will return an access token, expiry, token type, and refresh token
    # if the refresh token was valid. Else, it should return a 400 status error
    response = requests.post(URL.TOKEN, 
                             data=temp_payload, 
                             headers={"Content-Type": "application/x-www-form-urlencoded"})

    print("Token refresh failed. Trying to reauthenticate...")
    # If refreshing the token doesn't succeed (returns an error), the refresh token is likely 
    # expired. Try to authorize again
    if response.status_code != 200:
        # Set up oauth2 session. We'll only be using this to get the new login token
        oauth = requests_oauthlib.OAuth2Session(payload["client_id"], 
                                                redirect_uri=payload["redirect_uri"], 
                                                scope="offline_access")
        
        # Have user go to the authorization url generated by the oauth2 module
        # After user verification, the callback URL will contain the login token,
        # which we'll extract. This is the only time we use the oauth2 module
        authorization_url, state = oauth.authorization_url(URL.LOGIN)
    
        print(f"Please go to {authorization_url} and authorize access.")
        authorization_response = input("Enter the full callback URL: ")
        # Set up the payload to get the new access token
        temp_payload = {
            "client_id":        payload["client_id"],
            "client_secret":    payload["client_secret"],
            # Code retrieved from the initial auth process
            "code":             authorization_response.split("?")[1].split("&")[0].split("=")[1],
            "grant_type":       "authorization_code",
            "redirect_uri":     payload["redirect_uri"]
        }
        # This response will return an access token, expiry, token type, and refresh token
        # We are most interested in the access and refresh tokens
        response = requests.post(URL.TOKEN, 
                                 data=temp_payload, 
                                 headers={"Content-Type": "application/x-www-form-urlencoded"})

        # At this point, if we still aren't receiving a 200 OK status code, something else is wrong
        if response.status_code != 200:
            raise Exception(f"Authorization Failed! Error: {data['error']}")
        
    # Contains the access token and refresh token
    data = response.json()

    # We will add both tokens to the payload dictionary, then dump the dictionary to secrets.json
    payload["access_token"] = data["access_token"]
    payload["refresh_token"] = data["refresh_token"]
    with open('secrets.json', 'w') as of:
        json.dump(payload, of)

if __name__ == "__main__":
    payload = {}
    with open("secrets.json", 'r') as infile:
        payload = json.load(infile)

    print(json.dumps(payload, sort_keys=True, indent=4))
    access_token(payload)